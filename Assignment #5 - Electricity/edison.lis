     1                                  ;****************************************************************************************************************************
     2                                  ; Program name: "Electricity".  The intent of this program is to compute missing electrical information from            *
     3                                  ; user-inputted information. The educational purpose is to provide me with experience in pure assembly programming.          *                                                         *
     4                                  ; Copyright (C) 2025  Solivan Hiep                                                                                           *
     5                                  ; This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License  *
     6                                  ; version 3 as published by the Free Software Foundation.                                                                    *
     7                                  ; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied         *
     8                                  ; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     *
     9                                  ; A copy of the GNU General Public License v3 is available here:  <https://www.gnu.org/licenses/>.                           *
    10                                  ;****************************************************************************************************************************
    11                                  
    12                                  
    13                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
    14                                  
    15                                  ;Author information
    16                                  ;  Author name: Solivan Hiep
    17                                  ;  Author email: hiepsolivan@csu.fullerton.edu
    18                                  ;  CWID: 8848458756
    19                                  ;  Class: CPSC 240-03 - Class Nbr 13604
    20                                  ;
    21                                  ;Program information
    22                                  ;  Program name: Electricity
    23                                  ;  Programming languages: Ten modules in X86, one in bash
    24                                  ;  Date program began: 2025-Apr-04
    25                                  ;  Date of last update: 2025-Apr-12
    26                                  ;  Files in the program: faraday.asm, edison.asm, input_array.asm, atof.asm, isfloat.asm tesla.asm, ftoa.asm, syscall_fgets.asm, syscall_strlen.asm acdc.inc, r.sh
    27                                  ;
    28                                  ;Purpose
    29                                  ;  The intent of this program is to compute missing electrical information from
    30                                  ;  user-inputted information. The educational purpose is to provide me with experience in pure assembly programming.
    31                                  ;
    32                                  ;This file
    33                                  ;  File name: edison.asm
    34                                  ;  Language: X86-64
    35                                  ;  Development Platform: Windows 11 Enterprise Ver. 24H2. Intel(R) Core(TM) i3-8145U CPU @ 2.10GHz 2.30 GHz Processor. Running on Ubuntu 22.04.5 LTS.
    36                                  ;  Max page width: 189 columns
    37                                  ;  Assemble: nasm -f elf64 -l edison.lis -o edison.o edison.asm
    38                                  ;  Assemble (debug in GDB): nasm -f elf64 -gdwarf -l edison.lis -o edison.o edison.asm
    39                                  ;  Page width: 198 columns
    40                                  ;  Optimal print specification: Landscape, 7 points, monospace, 8Â½x11 paper
    41                                  ;  Prototype of this function: int edison()
    42                                  ;
    43                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
    44                                  ;
    45                                  ;===== Begin code area ====================================================================================================================================================
    46                                  
    47                                  ; Declarations
    48                                  %include "acdc.inc"
    49                              <1> ;=====Declarations =======================================================================
    50                              <1> ;These declarations are global to all the macros in this include file "acdc.inc".
    51                              <1> SYS_READ equ 0
    52                              <1> SYS_WRITE equ 1
    53                              <1> STDIN equ 0
    54                              <1> STDOUT equ 1
    55                              <1> 
    56                              <1> LF equ 10
    57                              <1> NULL equ 0
    58                              <1> 
    59 00000000 0A0A0A0A0A0A0A0A    <1> newline db 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa
    60                              <1> 
    61                              <1> ; Macro that backs up the GPRs
    62                              <1> %macro backup_gprs 0
    63                              <1>   push rbp
    64                              <1>   mov rbp, rsp
    65                              <1>   push rbx
    66                              <1>   push rcx
    67                              <1>   push rdx
    68                              <1>   push rdi
    69                              <1>   push rsi
    70                              <1>   push r8
    71                              <1>   push r9
    72                              <1>   push r10
    73                              <1>   push r11
    74                              <1>   push r12
    75                              <1>   push r13
    76                              <1>   push r14
    77                              <1>   push r15
    78                              <1>   pushf
    79                              <1> %endmacro
    80                              <1> 
    81                              <1> ; Macro that restores the GPRs
    82                              <1> %macro restore_gprs 0
    83                              <1>   popf
    84                              <1>   pop r15
    85                              <1>   pop r14
    86                              <1>   pop r13
    87                              <1>   pop r12
    88                              <1>   pop r11
    89                              <1>   pop r10
    90                              <1>   pop r9
    91                              <1>   pop r8
    92                              <1>   pop rsi
    93                              <1>   pop rdi
    94                              <1>   pop rdx
    95                              <1>   pop rcx
    96                              <1>   pop rbx
    97                              <1>   pop rbp
    98                              <1> %endmacro
    99                              <1> 
   100                              <1> ; Macro that back ups non-GPRs/SSEs to an array stored in parameter %1
   101                              <1> %macro backup_non_gprs 1
   102                              <1>   mov rax, 7
   103                              <1>   mov rdx, 0
   104                              <1>   xsave [%1]
   105                              <1> %endmacro
   106                              <1> 
   107                              <1> ; Macro that restores the non-GPRs/SSEs in storage array of parameter %1
   108                              <1> %macro restore_non_gprs 1
   109                              <1>   mov rax, 7
   110                              <1>   mov rdx, 0
   111                              <1>   xrstor [%1]
   112                              <1> %endmacro
   113                              <1> 
   114                              <1> ; Macro to print a newline
   115                              <1> %macro new_line 0
   116                              <1>   mov rax, SYS_WRITE
   117                              <1>   mov rdi, STDOUT
   118                              <1>   mov rsi, newline
   119                              <1>   mov rdx, 1
   120                              <1>   syscall
   121                              <1> %endmacro
   122                              <1> 
   123                              <1> ; Macro that reads each individual character from user input to store in parameter %1 [Limit: 50 chars (same as size of parameter %1)]
   124                              <1> %macro syscall_user_input_macro 1
   125                              <1>   ; %1 = Where to store the string
   126                              <1>   mov rbx, %1
   127                              <1> 
   128                              <1>   ; Maintain a counter to avoid over-indexing
   129                              <1>   xor r8, r8
   130                              <1> 
   131                              <1>   ; Set off the loop to read each character
   132                              <1>   %%read_chars:
   133                              <1>   ; Obtain one character from the user
   134                              <1>   mov rax, SYS_READ
   135                              <1>   mov rdi, STDIN
   136                              <1>   lea rsi, byte[chr] ; Use lea (Load Effective Address) to get the address of the character to be read
   137                              <1>   mov rdx, 1 ; Read one character
   138                              <1>   syscall
   139                              <1> 
   140                              <1>   ; Obtain the character from syscall stored in al [the low of rax's low's low] and check if its '\n' [Line feed]. If so, jump out; otherwise, continue
   141                              <1>   mov al, byte[chr]
   142                              <1>   cmp al, LF
   143                              <1>   je %%read_done
   144                              <1> 
   145                              <1>   ; Increment the counter and compare it to the max string size. If the counter is greater or equal, reset the loop to stop placing chars in the buffer. Otherwise, continue
   146                              <1>   inc r8
   147                              <1>   cmp r8, 50
   148                              <1>   jge %%read_chars ; Doing this will force the above read_done jump as the buffer is now cleared
   149                              <1> 
   150                              <1>   ; Update the string at the index r8 and the address of the string
   151                              <1>   mov byte[rbx], al
   152                              <1>   inc rbx
   153                              <1> 
   154                              <1>   ; Reset the loop
   155                              <1>   jmp %%read_chars
   156                              <1>   ; End of read_chars to read each character from user input
   157                              <1> 
   158                              <1>   ; Jump here once you are finished reading
   159                              <1>   %%read_done:
   160                              <1> 
   161                              <1>   ; Add a null terminator character to the end of the string
   162                              <1>   mov byte[rbx], NULL
   163                              <1> %endmacro
   164                              <1> 
   165                              <1> ; Macro that obtains the string length of the string stored in parameter %1 to output into parameter %2
   166                              <1> %macro syscall_strlen_macro 2
   167                              <1>   ; %1 - The string to find the length of
   168                              <1>   ; %2 - The length of the string
   169                              <1>   mov r12, %1
   170                              <1> 
   171                              <1>   ; Maintain a counter for each character
   172                              <1>   xor r8, r8
   173                              <1> 
   174                              <1>   ; Load the effective address of the string to use as an index
   175                              <1>   lea r9, [r12]
   176                              <1> 
   177                              <1>   ; Kick of the loop to get the string length
   178                              <1>   %%count_chars:
   179                              <1>   ; Check for the null character. If at null char, jump. Otherwise, continue
   180                              <1>   cmp byte [r9], 0
   181                              <1>   je %%count_done
   182                              <1> 
   183                              <1>   ; Increment both the character count and index then reset the loop
   184                              <1>   inc r8
   185                              <1>   inc r9
   186                              <1>   jmp %%count_chars
   187                              <1>   ; End of count_chars to obtain the string length
   188                              <1> 
   189                              <1>   ; Jump here to exit the macro
   190                              <1>   %%count_done:
   191                              <1>   mov %2, r8
   192                              <1> 
   193                              <1> %endmacro
    49                                  global edison
    50                                  extern atof
    51                                  extern input_array
    52                                  extern ftoa
    53                                  extern syscall_fgets
    54                                  extern syscall_strlen
    55                                  extern tesla
    56                                  
    57                                  SYS_WRITE equ 1
    58                                  STDOUT equ 1
    59                                  
    60                                  
    61                                  ; Declare initialized arrays
    62                                  segment .data
    63                                  
    64 00000000 506C6561736520656E-     full_name_prompt db "Please enter your full name: "
    64 00000009 74657220796F757220-
    64 00000012 66756C6C206E616D65-
    64 0000001B 3A20               
    65 0000001D 506C6561736520656E-     career_path_prompt db "Please enter the career path you are following: "
    65 00000026 746572207468652063-
    65 0000002F 617265657220706174-
    65 00000038 6820796F7520617265-
    65 00000041 20666F6C6C6F77696E-
    65 0000004A 673A20             
    66 0000004D 5468616E6B20796F75-     thank_you_career_msg db "Thank you.  We appreciate all "
    66 00000056 2E2020576520617070-
    66 0000005F 726563696174652061-
    66 00000068 6C6C20             
    67 0000006B 596F75722063697263-     circuit_desc_msg db "Your circuit has 3 sub-circuits."
    67 00000074 756974206861732033-
    67 0000007D 207375622D63697263-
    67 00000086 756974732E         
    68 0000008B 506C6561736520656E-     subcircuit_res_prompt db "Please enter the resistance in ohms on each of the three sub-circuits separated by ws."
    68 00000094 746572207468652072-
    68 0000009D 6573697374616E6365-
    68 000000A6 20696E206F686D7320-
    68 000000AF 6F6E2065616368206F-
    68 000000B8 662074686520746872-
    68 000000C1 6565207375622D6369-
    68 000000CA 726375697473207365-
    68 000000D3 706172617465642062-
    68 000000DC 792077732E         
    69 000000E1 732E                    append_s db "s."
    70 000000E3 5468616E6B20796F75-     thank_you_msg db "Thank you."
    70 000000EC 2E                 
    71 000000ED 54686520746F74616C-     total_res_msg db "The total resistance of the full circuit is computed to be "
    71 000000F6 20726573697374616E-
    71 000000FF 6365206F6620746865-
    71 00000108 2066756C6C20636972-
    71 00000111 637569742069732063-
    71 0000011A 6F6D70757465642074-
    71 00000123 6F20626520         
    72 00000128 20206F686D732E          ohms_msg db "  ohms."
    73 0000012F 454D4620697320636F-     emf_msg db "EMF is constant on every branch of any circuit."
    73 00000138 6E7374616E74206F6E-
    73 00000141 206576657279206272-
    73 0000014A 616E6368206F662061-
    73 00000153 6E7920636972637569-
    73 0000015C 742E               
    74 0000015E 506C6561736520656E-     emf_prompt db "Please enter the EMF of this circuit in volts:  "
    74 00000167 746572207468652045-
    74 00000170 4D46206F6620746869-
    74 00000179 732063697263756974-
    74 00000182 20696E20766F6C7473-
    74 0000018B 3A2020             
    75 0000018E 546865206375727265-     computed_current_msg db "The current flowing in this circuit has been computed:  "
    75 00000197 6E7420666C6F77696E-
    75 000001A0 6720696E2074686973-
    75 000001A9 206369726375697420-
    75 000001B2 686173206265656E20-
    75 000001BB 636F6D70757465643A-
    75 000001C4 2020               
    76 000001C6 20616D7073              amps_msg db " amps"
    77 000001CB 5468616E6B20796F75-     thank_you_msg_2 db "Thank you "
    77 000001D4 20                 
    78 000001D5 20666F72207573696E-     using_program_msg db " for using the program Electricity."
    78 000001DE 67207468652070726F-
    78 000001E7 6772616D20456C6563-
    78 000001F0 747269636974792E   
    79                                  
    80                                  ; Declare uninitialized arrays
    81                                  segment .bss
    82                                  align 64
    83 00000000 <res 340h>              backup_storage_area resb 832
    84                                  
    85 00000340 <res 32h>               full_name resb 50
    86 00000372 <res 32h>               career_path resb 50
    87 000003A4 <res 18h>               resistances resq 3
    88 000003BC ????????????????        emf resq 1
    89 000003C4 ??                      chr resb 1 ; Used in acdc.inc
    90                                  
    91                                  segment .text
    92                                  edison:
    93                                  
    94                                  ; Call the macro to back up the GPRs
    95                                  backup_gprs
    63 00000008 55                  <1>  push rbp
    64 00000009 4889E5              <1>  mov rbp, rsp
    65 0000000C 53                  <1>  push rbx
    66 0000000D 51                  <1>  push rcx
    67 0000000E 52                  <1>  push rdx
    68 0000000F 57                  <1>  push rdi
    69 00000010 56                  <1>  push rsi
    70 00000011 4150                <1>  push r8
    71 00000013 4151                <1>  push r9
    72 00000015 4152                <1>  push r10
    73 00000017 4153                <1>  push r11
    74 00000019 4154                <1>  push r12
    75 0000001B 4155                <1>  push r13
    76 0000001D 4156                <1>  push r14
    77 0000001F 4157                <1>  push r15
    78 00000021 9C                  <1>  pushf
    96                                  
    97                                  ; Call the macro to back up the non-GPRs/SSEs into the backup_storage_area
    98                                  backup_non_gprs backup_storage_area
   102 00000022 B807000000          <1>  mov rax, 7
   103 00000027 BA00000000          <1>  mov rdx, 0
   104 0000002C 0FAE2425[00000000]  <1>  xsave [%1]
    99                                  
   100                                  ; Print out the prompt for the user to input their full name
   101 00000034 B801000000              mov rax, SYS_WRITE
   102 00000039 BF01000000              mov rdi, STDOUT
   103 0000003E 48BE-                   mov rsi, full_name_prompt
   103 00000040 [0000000000000000] 
   104 00000048 BA1D000000              mov rdx, 29
   105 0000004D 0F05                    syscall
   106                                  
   107                                  ; Call syscall_fgets [void syscall_fgets(char string[])] to get the user input for their full name via sycall
   108 0000004F B800000000              mov rax, 0
   109 00000054 48BF-                   mov rdi, full_name
   109 00000056 [4003000000000000] 
   110 0000005E E8(00000000)            call syscall_fgets
   111                                  
   112                                  ; Print out the prompt for the user to input their career path
   113 00000063 B801000000              mov rax, SYS_WRITE
   114 00000068 BF01000000              mov rdi, STDOUT
   115 0000006D 48BE-                   mov rsi, career_path_prompt
   115 0000006F [1D00000000000000] 
   116 00000077 BA30000000              mov rdx, 48
   117 0000007C 0F05                    syscall
   118                                  
   119                                  ; Call syscall_fgets [void syscall_fgets(char string[])] to get the user input for their career path via syscall
   120 0000007E B800000000              mov rax, 0
   121 00000083 48BF-                   mov rdi, career_path
   121 00000085 [7203000000000000] 
   122 0000008D E8(00000000)            call syscall_fgets
   123                                  
   124                                  ; Obtain the length of the user-inputted career for usage in syscall and store it in non-volatile r12 by calling syscall_strlen [long syscall_strlen(char string[])]
   125 00000092 B800000000              mov rax, 0
   126 00000097 48BF-                   mov rdi, career_path
   126 00000099 [7203000000000000] 
   127 000000A1 E8(00000000)            call syscall_strlen
   128 000000A6 4989C4                  mov r12, rax
   129                                  
   130                                  ; Remove the newline character from the end of the user-inputted career
   131 000000A9 41C68424[72030000]-     mov [career_path + r12], byte 0
   131 000000B1 00                 
   132                                  
   133                                  ; Print out the message thanking the user and expressing appreciation for the user's tite
   134 000000B2 B801000000              mov rax, SYS_WRITE
   135 000000B7 BF01000000              mov rdi, STDOUT
   136 000000BC 48BE-                   mov rsi, thank_you_career_msg
   136 000000BE [4D00000000000000] 
   137 000000C6 BA1E000000              mov rdx, 30
   138 000000CB 0F05                    syscall
   139                                  
   140                                  ; Print out the user-inputted career.
   141 000000CD B801000000              mov rax, SYS_WRITE
   142 000000D2 BF01000000              mov rdi, STDOUT
   143 000000D7 48BE-                   mov rsi, career_path
   143 000000D9 [7203000000000000] 
   144 000000E1 4C89E2                  mov rdx, r12
   145 000000E4 0F05                    syscall
   146                                  
   147                                  ; Print out an appended 's' and period (Author's Note: Rather than appending into the array, append the output. This is to allow for appending even if the career exceeds the 50 char limit)
   148 000000E6 B801000000              mov rax, SYS_WRITE
   149 000000EB BF01000000              mov rdi, STDOUT
   150 000000F0 48BE-                   mov rsi, append_s
   150 000000F2 [E100000000000000] 
   151 000000FA BA02000000              mov rdx, 2
   152 000000FF 0F05                    syscall
   153                                  
   154                                  ; Call the macro to print out two newlines
   155                                  new_line
   116 00000101 B801000000          <1>  mov rax, SYS_WRITE
   117 00000106 BF01000000          <1>  mov rdi, STDOUT
   118 0000010B 48BE-               <1>  mov rsi, newline
   118 0000010D [0000000000000000]  <1>
   119 00000115 BA01000000          <1>  mov rdx, 1
   120 0000011A 0F05                <1>  syscall
   156                                  new_line
   116 0000011C B801000000          <1>  mov rax, SYS_WRITE
   117 00000121 BF01000000          <1>  mov rdi, STDOUT
   118 00000126 48BE-               <1>  mov rsi, newline
   118 00000128 [0000000000000000]  <1>
   119 00000130 BA01000000          <1>  mov rdx, 1
   120 00000135 0F05                <1>  syscall
   157                                  
   158                                  ; Print out the message describing the circuit structure
   159 00000137 B801000000              mov rax, SYS_WRITE
   160 0000013C BF01000000              mov rdi, STDOUT
   161 00000141 48BE-                   mov rsi, circuit_desc_msg
   161 00000143 [6B00000000000000] 
   162 0000014B BA20000000              mov rdx, 32
   163 00000150 0F05                    syscall
   164                                  
   165                                  ; Call the macro to print a newline
   166                                  new_line
   116 00000152 B801000000          <1>  mov rax, SYS_WRITE
   117 00000157 BF01000000          <1>  mov rdi, STDOUT
   118 0000015C 48BE-               <1>  mov rsi, newline
   118 0000015E [0000000000000000]  <1>
   119 00000166 BA01000000          <1>  mov rdx, 1
   120 0000016B 0F05                <1>  syscall
   167                                  
   168                                  ; Print out the prompt for the user to enter their 3 subcircuits
   169 0000016D B801000000              mov rax, SYS_WRITE
   170 00000172 BF01000000              mov rdi, STDOUT
   171 00000177 48BE-                   mov rsi, subcircuit_res_prompt
   171 00000179 [8B00000000000000] 
   172 00000181 BA56000000              mov rdx, 86
   173 00000186 0F05                    syscall
   174                                  
   175                                  ; Call the macro to print out a newline
   176                                  new_line
   116 00000188 B801000000          <1>  mov rax, SYS_WRITE
   117 0000018D BF01000000          <1>  mov rdi, STDOUT
   118 00000192 48BE-               <1>  mov rsi, newline
   118 00000194 [0000000000000000]  <1>
   119 0000019C BA01000000          <1>  mov rdx, 1
   120 000001A1 0F05                <1>  syscall
   177                                  
   178                                  ; Call input_array [void input_array(double array[], long capacity)] to input resistances
   179 000001A3 B800000000              mov rax, 0
   180 000001A8 48BF-                   mov rdi, resistances
   180 000001AA [A403000000000000] 
   181 000001B2 BE03000000              mov rsi, 3
   182 000001B7 E8(00000000)            call input_array
   183                                  
   184                                  ; Print out a thank you message
   185 000001BC B801000000              mov rax, SYS_WRITE
   186 000001C1 BF01000000              mov rdi, STDOUT
   187 000001C6 48BE-                   mov rsi, thank_you_msg
   187 000001C8 [E300000000000000] 
   188 000001D0 BA0A000000              mov rdx, 10
   189 000001D5 0F05                    syscall
   190                                  
   191                                  ; Call the macro to print out a newline
   192                                  new_line
   116 000001D7 B801000000          <1>  mov rax, SYS_WRITE
   117 000001DC BF01000000          <1>  mov rdi, STDOUT
   118 000001E1 48BE-               <1>  mov rsi, newline
   118 000001E3 [0000000000000000]  <1>
   119 000001EB BA01000000          <1>  mov rdx, 1
   120 000001F0 0F05                <1>  syscall
   193                                  
   194                                  ; Calculate the total resistance of the full circuit by calling tesla [double tesla(double array[])]
   195 000001F2 B800000000              mov rax, 0
   196 000001F7 48BF-                   mov rdi, resistances
   196 000001F9 [A403000000000000] 
   197 00000201 E8(00000000)            call tesla ; Calculations stored in xmm0
   198 00000206 F2440F10E0              movsd xmm12, xmm0
   199                                  
   200                                  ; Call ftoa [char * ftoa(double num)] to obtain an ASCII string of the computed resistance so it can be printed
   201 0000020B B801000000              mov rax, 1
   202 00000210 F2410F10C4              movsd xmm0, xmm12
   203 00000215 E8(00000000)            call ftoa ; Calculations stored in rax
   204 0000021A 4989C5                  mov r13, rax
   205                                  
   206                                  ; Call syscall_strlen [long syscall_strlen(char string[])] to obtain the length of the resistance string so it can be printed
   207 0000021D B800000000              mov rax, 0
   208 00000222 4C89EF                  mov rdi, r13
   209 00000225 E8(00000000)            call syscall_strlen ; Calculations stored in rax
   210 0000022A 4989C6                  mov r14, rax
   211                                  
   212                                  ; Print out the message explaining the computed resistance
   213 0000022D B801000000              mov rax, SYS_WRITE
   214 00000232 BF01000000              mov rdi, STDOUT
   215 00000237 48BE-                   mov rsi, total_res_msg
   215 00000239 [ED00000000000000] 
   216 00000241 BA3B000000              mov rdx, 59
   217 00000246 0F05                    syscall
   218                                  
   219                                  ; Print out the computed resistance
   220 00000248 B801000000              mov rax, SYS_WRITE
   221 0000024D BF01000000              mov rdi, STDOUT
   222 00000252 4C89EE                  mov rsi, r13
   223 00000255 4C89F2                  mov rdx, r14
   224 00000258 0F05                    syscall
   225                                  
   226                                  ; Print out the message adding the ohm unit to the computed resistance
   227 0000025A B801000000              mov rax, SYS_WRITE
   228 0000025F BF01000000              mov rdi, STDOUT
   229 00000264 48BE-                   mov rsi, ohms_msg
   229 00000266 [2801000000000000] 
   230 0000026E BA07000000              mov rdx, 7
   231 00000273 0F05                    syscall
   232                                  
   233                                  ; Print out two newlines
   234                                  new_line
   116 00000275 B801000000          <1>  mov rax, SYS_WRITE
   117 0000027A BF01000000          <1>  mov rdi, STDOUT
   118 0000027F 48BE-               <1>  mov rsi, newline
   118 00000281 [0000000000000000]  <1>
   119 00000289 BA01000000          <1>  mov rdx, 1
   120 0000028E 0F05                <1>  syscall
   235                                  new_line
   116 00000290 B801000000          <1>  mov rax, SYS_WRITE
   117 00000295 BF01000000          <1>  mov rdi, STDOUT
   118 0000029A 48BE-               <1>  mov rsi, newline
   118 0000029C [0000000000000000]  <1>
   119 000002A4 BA01000000          <1>  mov rdx, 1
   120 000002A9 0F05                <1>  syscall
   236                                  
   237                                  ; Print out the message explaining EMF behavior on a circuit
   238 000002AB B801000000              mov rax, SYS_WRITE
   239 000002B0 BF01000000              mov rdi, STDOUT
   240 000002B5 48BE-                   mov rsi, emf_msg
   240 000002B7 [2F01000000000000] 
   241 000002BF BA2F000000              mov rdx, 47
   242 000002C4 0F05                    syscall
   243                                  
   244                                  ; Call the macro to print out a newline
   245                                  new_line
   116 000002C6 B801000000          <1>  mov rax, SYS_WRITE
   117 000002CB BF01000000          <1>  mov rdi, STDOUT
   118 000002D0 48BE-               <1>  mov rsi, newline
   118 000002D2 [0000000000000000]  <1>
   119 000002DA BA01000000          <1>  mov rdx, 1
   120 000002DF 0F05                <1>  syscall
   246                                  
   247                                  ; Print out the prompt for the user to input the EMF of the circuit in volts
   248 000002E1 B801000000              mov rax, SYS_WRITE
   249 000002E6 BF01000000              mov rdi, STDOUT
   250 000002EB 48BE-                   mov rsi, emf_prompt
   250 000002ED [5E01000000000000] 
   251 000002F5 BA30000000              mov rdx, 48
   252 000002FA 0F05                    syscall
   253                                  
   254                                  ; Call syscall_fgets [void syscall_fgets(char string[])] to get the user input for their EMF via syscall
   255 000002FC B800000000              mov rax, 0
   256 00000301 48BF-                   mov rdi, emf
   256 00000303 [BC03000000000000] 
   257 0000030B E8(00000000)            call syscall_fgets
   258                                  
   259                                  ; Convert the obtained user input into a float for use in computations via atof [double atof(char string[])]
   260 00000310 B800000000              mov rax, 0
   261 00000315 48BF-                   mov rdi, emf
   261 00000317 [BC03000000000000] 
   262 0000031F E8(00000000)            call atof
   263 00000324 F2440F10E8              movsd xmm13, xmm0
   264                                  
   265                                  ; Compute the current using the formula: I (Current) = R (Resistance) / E (EMF)
   266 00000329 F2450F10F4              movsd xmm14, xmm12
   267                                  ;divsd xmm14, xmm13
   268                                  
   269                                  ; Print out a thank you message
   270 0000032E B801000000              mov rax, SYS_WRITE
   271 00000333 BF01000000              mov rdi, STDOUT
   272 00000338 48BE-                   mov rsi, thank_you_msg
   272 0000033A [E300000000000000] 
   273 00000342 BA0A000000              mov rdx, 10
   274 00000347 0F05                    syscall
   275                                  
   276                                  ; Call the macro to print out two newlines
   277                                  new_line
   116 00000349 B801000000          <1>  mov rax, SYS_WRITE
   117 0000034E BF01000000          <1>  mov rdi, STDOUT
   118 00000353 48BE-               <1>  mov rsi, newline
   118 00000355 [0000000000000000]  <1>
   119 0000035D BA01000000          <1>  mov rdx, 1
   120 00000362 0F05                <1>  syscall
   278                                  new_line
   116 00000364 B801000000          <1>  mov rax, SYS_WRITE
   117 00000369 BF01000000          <1>  mov rdi, STDOUT
   118 0000036E 48BE-               <1>  mov rsi, newline
   118 00000370 [0000000000000000]  <1>
   119 00000378 BA01000000          <1>  mov rdx, 1
   120 0000037D 0F05                <1>  syscall
   279                                  
   280                                  ; Print out a message explaining that the current has been computed
   281 0000037F B801000000              mov rax, SYS_WRITE
   282 00000384 BF01000000              mov rdi, STDOUT
   283 00000389 48BE-                   mov rsi, computed_current_msg
   283 0000038B [8E01000000000000] 
   284 00000393 BA38000000              mov rdx, 56
   285 00000398 0F05                    syscall
   286                                  
   287                                  ; Call ftoa [char * ftoa(double num)] to obtain an ASCII string of the computed current so it can be printed
   288 0000039A B801000000              mov rax, 1
   289 0000039F F2410F10C6              movsd xmm0, xmm14
   290 000003A4 E8(00000000)            call ftoa ; Calculations stored in rax
   291 000003A9 4989C7                  mov r15, rax
   292                                  
   293                                  ; Call syscall_strlen [long syscall_strlen(char string[])] to obtain the length of the current string so it can be printed
   294 000003AC B800000000              mov rax, 0
   295 000003B1 4C89FF                  mov rdi, r15
   296 000003B4 E8(00000000)            call syscall_strlen ; Calculations stored in rax
   297 000003B9 4989C3                  mov r11, rax
   298                                  
   299                                  ; Print out the computed current
   300 000003BC B801000000              mov rax, SYS_WRITE
   301 000003C1 BF01000000              mov rdi, STDOUT
   302 000003C6 4C89FE                  mov rsi, r15
   303 000003C9 4C89DA                  mov rdx, r11
   304 000003CC 0F05                    syscall
   305                                  
   306                                  ; Print out the message attaching the amps unit to the computed current
   307 000003CE B801000000              mov rax, SYS_WRITE
   308 000003D3 BF01000000              mov rdi, STDOUT
   309 000003D8 48BE-                   mov rsi, amps_msg
   309 000003DA [C601000000000000] 
   310 000003E2 BA05000000              mov rdx, 5
   311 000003E7 0F05                    syscall
   312                                  
   313                                  ; Call the macro to print a newline
   314                                  new_line
   116 000003E9 B801000000          <1>  mov rax, SYS_WRITE
   117 000003EE BF01000000          <1>  mov rdi, STDOUT
   118 000003F3 48BE-               <1>  mov rsi, newline
   118 000003F5 [0000000000000000]  <1>
   119 000003FD BA01000000          <1>  mov rdx, 1
   120 00000402 0F05                <1>  syscall
   315                                  
   316                                  ; Obtain the length of the user's full name via syscall_strlen [long syscall_strlen(char string[])] for use in printing
   317 00000404 B800000000              mov rax, 0
   318 00000409 48BF-                   mov rdi, full_name
   318 0000040B [4003000000000000] 
   319 00000413 E8(00000000)            call syscall_strlen
   320 00000418 4989C2                  mov r10, rax
   321                                  
   322                                  ; Print out a thank you message (without a period)
   323 0000041B B801000000              mov rax, SYS_WRITE
   324 00000420 BF01000000              mov rdi, STDOUT
   325 00000425 48BE-                   mov rsi, thank_you_msg_2
   325 00000427 [CB01000000000000] 
   326 0000042F BA0A000000              mov rdx, 10
   327 00000434 0F05                    syscall
   328                                  
   329                                  ; Print out the user's full name
   330 00000436 B801000000              mov rax, SYS_WRITE
   331 0000043B BF01000000              mov rdi, STDOUT
   332 00000440 48BE-                   mov rsi, full_name
   332 00000442 [4003000000000000] 
   333 0000044A 4C89D2                  mov rdx, r10
   334 0000044D 0F05                    syscall
   335                                  
   336                                  ; Finish printing out the thank you message
   337 0000044F B801000000              mov rax, SYS_WRITE
   338 00000454 BF01000000              mov rdi, STDOUT
   339 00000459 48BE-                   mov rsi, using_program_msg
   339 0000045B [D501000000000000] 
   340 00000463 BA23000000              mov rdx, 35
   341 00000468 0F05                    syscall
   342                                  
   343                                  ; Call the macro to print out two newlines
   344                                  new_line
   116 0000046A B801000000          <1>  mov rax, SYS_WRITE
   117 0000046F BF01000000          <1>  mov rdi, STDOUT
   118 00000474 48BE-               <1>  mov rsi, newline
   118 00000476 [0000000000000000]  <1>
   119 0000047E BA01000000          <1>  mov rdx, 1
   120 00000483 0F05                <1>  syscall
   345                                  new_line
   116 00000485 B801000000          <1>  mov rax, SYS_WRITE
   117 0000048A BF01000000          <1>  mov rdi, STDOUT
   118 0000048F 48BE-               <1>  mov rsi, newline
   118 00000491 [0000000000000000]  <1>
   119 00000499 BA01000000          <1>  mov rdx, 1
   120 0000049E 0F05                <1>  syscall
   346                                  
   347                                  ; Call the macro to restore the non-GPRs/SSEs from the backup_storage_area
   348                                  restore_non_gprs backup_storage_area
   109 000004A0 B807000000          <1>  mov rax, 7
   110 000004A5 BA00000000          <1>  mov rdx, 0
   111 000004AA 0FAE2C25[00000000]  <1>  xrstor [%1]
   349                                  
   350                                  ; Send back the computed current back to the caller
   351 000004B2 4C89F8                  mov rax, r15
   352                                  
   353                                  ; Call the macro to restore the GPRs
   354                                  restore_gprs
    83 000004B5 9D                  <1>  popf
    84 000004B6 415F                <1>  pop r15
    85 000004B8 415E                <1>  pop r14
    86 000004BA 415D                <1>  pop r13
    87 000004BC 415C                <1>  pop r12
    88 000004BE 415B                <1>  pop r11
    89 000004C0 415A                <1>  pop r10
    90 000004C2 4159                <1>  pop r9
    91 000004C4 4158                <1>  pop r8
    92 000004C6 5E                  <1>  pop rsi
    93 000004C7 5F                  <1>  pop rdi
    94 000004C8 5A                  <1>  pop rdx
    95 000004C9 59                  <1>  pop rcx
    96 000004CA 5B                  <1>  pop rbx
    97 000004CB 5D                  <1>  pop rbp
   355                                  
   356 000004CC C3                      ret

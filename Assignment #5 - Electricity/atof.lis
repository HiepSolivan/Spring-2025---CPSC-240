     1                                  ;****************************************************************************************************************************
     2                                  ; Program name: "Electricity".  The intent of this program is to compute missing electrical information from            *
     3                                  ; user-inputted information. The educational purpose is to provide me with experience in pure assembly programming.          *                                                         *
     4                                  ; Copyright (C) 2025  Solivan Hiep                                                                                           *
     5                                  ; This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License  *
     6                                  ; version 3 as published by the Free Software Foundation.                                                                    *
     7                                  ; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied         *
     8                                  ; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     *
     9                                  ; A copy of the GNU General Public License v3 is available here:  <https://www.gnu.org/licenses/>.                           *
    10                                  ;****************************************************************************************************************************
    11                                  
    12                                  
    13                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
    14                                  
    15                                  ;Author information
    16                                  ;  Author name: Solivan Hiep
    17                                  ;  Author email: hiepsolivan@csu.fullerton.edu
    18                                  ;  CWID: 8848458756
    19                                  ;  Class: CPSC 240-03 - Class Nbr 13604
    20                                  ;
    21                                  ;Program information
    22                                  ;  Program name: Electricity
    23                                  ;  Programming languages: Ten modules in X86, one in bash
    24                                  ;  Date program began: 2025-Apr-04
    25                                  ;  Date of last update: 2025-Apr-12
    26                                  ;  Files in the program: faraday.asm, edison.asm, input_array.asm, atof.asm, isfloat.asm tesla.asm, ftoa.asm, syscall_fgets.asm, syscall_strlen.asm acdc.inc, r.sh
    27                                  ;
    28                                  ;Purpose
    29                                  ;  The intent of this program is to compute missing electrical information from
    30                                  ;  user-inputted information. The educational purpose is to provide me with experience in pure assembly programming.
    31                                  ;
    32                                  ;This file
    33                                  ;  File name: atof.asm
    34                                  ;  Language: X86-64
    35                                  ;  Development Platform: Windows 11 Enterprise Ver. 24H2. Intel(R) Core(TM) i3-8145U CPU @ 2.10GHz 2.30 GHz Processor. Running on Ubuntu 22.04.5 LTS.
    36                                  ;  Max page width: 189 columns
    37                                  ;  Assemble: nasm -f elf64 -l atof.lis -o atof.o atof.asm
    38                                  ;  Assemble (debug in GDB): nasm -f elf64 -gdwarf -l atof.lis -o atof.o atof.asm
    39                                  ;  Page width: 198 columns
    40                                  ;  Optimal print specification: Landscape, 7 points, monospace, 8Â½x11 paper
    41                                  ;  Prototype of this function: double atof(char string[])
    42                                  ;
    43                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
    44                                  ;
    45                                  ;===== Begin code area ====================================================================================================================================================
    46                                  
    47                                  ; Declarations
    48                                  %include "acdc.inc"
    49                              <1> ;=====Declarations =======================================================================
    50                              <1> ;These declarations are global to all the macros in this include file "acdc.inc".
    51                              <1> SYS_READ equ 0
    52                              <1> SYS_WRITE equ 1
    53                              <1> STDIN equ 0
    54                              <1> STDOUT equ 1
    55                              <1> 
    56                              <1> LF equ 10
    57                              <1> NULL equ 0
    58                              <1> 
    59 00000000 0A0A0A0A0A0A0A0A    <1> newline db 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa
    60                              <1> 
    61                              <1> ; Macro that backs up the GPRs
    62                              <1> %macro backup_gprs 0
    63                              <1>   push rbp
    64                              <1>   mov rbp, rsp
    65                              <1>   push rbx
    66                              <1>   push rcx
    67                              <1>   push rdx
    68                              <1>   push rdi
    69                              <1>   push rsi
    70                              <1>   push r8
    71                              <1>   push r9
    72                              <1>   push r10
    73                              <1>   push r11
    74                              <1>   push r12
    75                              <1>   push r13
    76                              <1>   push r14
    77                              <1>   push r15
    78                              <1>   pushf
    79                              <1> %endmacro
    80                              <1> 
    81                              <1> ; Macro that restores the GPRs
    82                              <1> %macro restore_gprs 0
    83                              <1>   popf
    84                              <1>   pop r15
    85                              <1>   pop r14
    86                              <1>   pop r13
    87                              <1>   pop r12
    88                              <1>   pop r11
    89                              <1>   pop r10
    90                              <1>   pop r9
    91                              <1>   pop r8
    92                              <1>   pop rsi
    93                              <1>   pop rdi
    94                              <1>   pop rdx
    95                              <1>   pop rcx
    96                              <1>   pop rbx
    97                              <1>   pop rbp
    98                              <1> %endmacro
    99                              <1> 
   100                              <1> ; Macro that back ups non-GPRs/SSEs to an array stored in parameter %1
   101                              <1> %macro backup_non_gprs 1
   102                              <1>   mov rax, 7
   103                              <1>   mov rdx, 0
   104                              <1>   xsave [%1]
   105                              <1> %endmacro
   106                              <1> 
   107                              <1> ; Macro that restores the non-GPRs/SSEs in storage array of parameter %1
   108                              <1> %macro restore_non_gprs 1
   109                              <1>   mov rax, 7
   110                              <1>   mov rdx, 0
   111                              <1>   xrstor [%1]
   112                              <1> %endmacro
   113                              <1> 
   114                              <1> ; Macro to print a newline
   115                              <1> %macro new_line 0
   116                              <1>   mov rax, SYS_WRITE
   117                              <1>   mov rdi, STDOUT
   118                              <1>   mov rsi, newline
   119                              <1>   mov rdx, 1
   120                              <1>   syscall
   121                              <1> %endmacro
   122                              <1> 
   123                              <1> ; Macro that reads each individual character from user input to store in parameter %1 [Limit: 50 chars (same as size of parameter %1)]
   124                              <1> %macro syscall_user_input_macro 1
   125                              <1>   ; %1 = Where to store the string
   126                              <1>   mov rbx, %1
   127                              <1> 
   128                              <1>   ; Maintain a counter to avoid over-indexing
   129                              <1>   xor r8, r8
   130                              <1> 
   131                              <1>   ; Set off the loop to read each character
   132                              <1>   %%read_chars:
   133                              <1>   ; Obtain one character from the user
   134                              <1>   mov rax, SYS_READ
   135                              <1>   mov rdi, STDIN
   136                              <1>   lea rsi, byte[chr] ; Use lea (Load Effective Address) to get the address of the character to be read
   137                              <1>   mov rdx, 1 ; Read one character
   138                              <1>   syscall
   139                              <1> 
   140                              <1>   ; Obtain the character from syscall stored in al [the low of rax's low's low] and check if its '\n' [Line feed]. If so, jump out; otherwise, continue
   141                              <1>   mov al, byte[chr]
   142                              <1>   cmp al, LF
   143                              <1>   je %%read_done
   144                              <1> 
   145                              <1>   ; Increment the counter and compare it to the max string size. If the counter is greater or equal, reset the loop to stop placing chars in the buffer. Otherwise, continue
   146                              <1>   inc r8
   147                              <1>   cmp r8, 50
   148                              <1>   jge %%read_chars ; Doing this will force the above read_done jump as the buffer is now cleared
   149                              <1> 
   150                              <1>   ; Update the string at the index r8 and the address of the string
   151                              <1>   mov byte[rbx], al
   152                              <1>   inc rbx
   153                              <1> 
   154                              <1>   ; Reset the loop
   155                              <1>   jmp %%read_chars
   156                              <1>   ; End of read_chars to read each character from user input
   157                              <1> 
   158                              <1>   ; Jump here once you are finished reading
   159                              <1>   %%read_done:
   160                              <1> 
   161                              <1>   ; Add a null terminator character to the end of the string
   162                              <1>   mov byte[rbx], NULL
   163                              <1> %endmacro
   164                              <1> 
   165                              <1> ; Macro that obtains the string length of the string stored in parameter %1 to output into parameter %2
   166                              <1> %macro syscall_strlen_macro 2
   167                              <1>   ; %1 - The string to find the length of
   168                              <1>   ; %2 - The length of the string
   169                              <1>   mov r12, %1
   170                              <1> 
   171                              <1>   ; Maintain a counter for each character
   172                              <1>   xor r8, r8
   173                              <1> 
   174                              <1>   ; Load the effective address of the string to use as an index
   175                              <1>   lea r9, [r12]
   176                              <1> 
   177                              <1>   ; Kick of the loop to get the string length
   178                              <1>   %%count_chars:
   179                              <1>   ; Check for the null character. If at null char, jump. Otherwise, continue
   180                              <1>   cmp byte [r9], 0
   181                              <1>   je %%count_done
   182                              <1> 
   183                              <1>   ; Increment both the character count and index then reset the loop
   184                              <1>   inc r8
   185                              <1>   inc r9
   186                              <1>   jmp %%count_chars
   187                              <1>   ; End of count_chars to obtain the string length
   188                              <1> 
   189                              <1>   ; Jump here to exit the macro
   190                              <1>   %%count_done:
   191                              <1>   mov %2, r8
   192                              <1> 
   193                              <1> %endmacro
    49                                  global atof
    50                                  
    51                                  ; Declare initialized arrays
    52                                  segment .data
    53 00000000 0000000000000080        negative_mask dq 0x8000000000000000
    54                                  
    55                                  ; Declare uninitialized array
    56                                  segment .bss
    57                                  align 64
    58 00000000 <res 340h>              backup_storage_area resb 832
    59                                  
    60                                  segment .text
    61                                  atof:
    62                                  ; Call the macro to back up the GPRs
    63                                  backup_gprs
    63 00000008 55                  <1>  push rbp
    64 00000009 4889E5              <1>  mov rbp, rsp
    65 0000000C 53                  <1>  push rbx
    66 0000000D 51                  <1>  push rcx
    67 0000000E 52                  <1>  push rdx
    68 0000000F 57                  <1>  push rdi
    69 00000010 56                  <1>  push rsi
    70 00000011 4150                <1>  push r8
    71 00000013 4151                <1>  push r9
    72 00000015 4152                <1>  push r10
    73 00000017 4153                <1>  push r11
    74 00000019 4154                <1>  push r12
    75 0000001B 4155                <1>  push r13
    76 0000001D 4156                <1>  push r14
    77 0000001F 4157                <1>  push r15
    78 00000021 9C                  <1>  pushf
    64                                  
    65                                  ; Call the macro to back up the non-GPRs/SSEs into backup_storage_area
    66                                  backup_non_gprs backup_storage_area
   102 00000022 B807000000          <1>  mov rax, 7
   103 00000027 BA00000000          <1>  mov rdx, 0
   104 0000002C 0FAE2425[00000000]  <1>  xsave [%1]
    67                                  
    68                                  ; Move the received arguments (the ASCII string) into the non-volatile register r12.
    69 00000034 4989FC                  mov r12, rdi
    70                                  
    71                                  ; Maintain a counter to use to find the decimal point
    72 00000037 4D31ED                  xor r13, r13
    73                                  
    74                                  ; Start the loop that checks each ASCII char in search of a decimal point (Note: We already know there is only 1 decimal point from isfloat)
    75                                  find_decimal_point:
    76                                  
    77                                  ; Compare the current ASCII char at the counter r13 with '.' to determine the index of the decimal place. If '.' is found, jump. Otherwise, continue.
    78 0000003A 43803C2C2E              cmp byte[r12 + r13], '.'
    79 0000003F 7405                    je found_decimal_point
    80 00000041 49FFC5                  inc r13
    81 00000044 EBF4                    jmp find_decimal_point
    82                                  
    83                                  ; End of find_decimal_point to iterate through the ASCII string to find the index of the decimal point
    84                                  
    85                                  ; Prepares to convert the integer portion of the ASCII string
    86                                  found_decimal_point:
    87                                  
    88                                  ; Maintain registers to use as the sum for the integer portion, marker for the place value, a copy of the index of the decimal point, and a flag for the negative sign
    89 00000046 4D31F6                  xor r14, r14
    90 00000049 41BF01000000            mov r15, 1
    91 0000004F 4D89EB                  mov r11, r13
    92 00000052 4D31D2                  xor r10, r10
    93                                  
    94                                  ; Decrement the index of the decimal place as we are only converting the integer portion
    95 00000055 49FFCB                  dec r11
    96                                  
    97                                  ; Start the loop to iterate through the integer portion of the ASCII string for conversion BACKWARDS
    98                                  convert_int_portion:
    99                                  
   100                                  ; Check if we have reached a sign. If so either turn on the negative sign flag (r10) or jump. Otherwise, continue.
   101 00000058 438A041C                mov al, byte[r12 + r11]
   102 0000005C 3C2B                    cmp al, '+'
   103 0000005E 7424                    je finish_int_portion
   104 00000060 3C2D                    cmp al, '-'
   105 00000062 7418                    je int_negative_sign
   106                                  
   107                                  ; Convert the current ASCII char by subtracting the ASCII code for '0' to the current character to yield the integer value
   108 00000064 2C30                    sub al, '0'
   109                                  
   110                                  ; Multiply the extracted integer value by the marker value (r15), increment the marker value by 10, and add it to our sum (r14)
   111 00000066 490FAFC7                imul rax, r15 ; We are using a 64-bit register (rax) rather than the 8-bit register (al) as we have yielded an int from the previous instruction
   112 0000006A 4D6BFF0A                imul r15, 10
   113 0000006E 4901C6                  add r14, rax
   114                                  
   115                                  ; Decrement the index then check for over-indexing by checking if r11 < 0. If so, jump. Otherwise, reset the loop
   116 00000071 49FFCB                  dec r11
   117 00000074 4983FB00                cmp r11, 0
   118 00000078 7C0A                    jl finish_int_portion
   119 0000007A EBDC                    jmp convert_int_portion
   120                                  
   121                                  ; End of convert_int_portion to iterate through the integer portion of the ASCII string for backwards conversion
   122                                  
   123                                  ; Jump here if we found a negative sign to set on the negative sign flag (r10)
   124                                  int_negative_sign:
   125                                  
   126                                  ; Set on the negative sign flag by turning it to 1 then proceed to finish_int_portion
   127 0000007C 41BA01000000            mov r10, 1
   128 00000082 EB00                    jmp finish_int_portion
   129                                  
   130                                  ; End of int_negative_sign to set on the negative sign flag
   131                                  
   132                                  ; Prepare to convert the decimal portion of the ASCII string
   133                                  finish_int_portion:
   134                                  
   135                                  ; Move 10.0 into xmm11 by first moving it into rax then converting it
   136 00000084 B80A000000              mov rax, 10
   137 00000089 F24C0F2AD8              cvtsi2sd xmm11, rax
   138                                  
   139                                  ; Maintain registers for use as a decimal sum and a marker for place value
   140 0000008E 66450F57E4              xorpd xmm12, xmm12
   141 00000093 F2450F10EB              movsd xmm13, xmm11
   142                                  
   143                                  ; Increment the index of the decimal place as we are only converting the integer portion
   144 00000098 49FFC5                  inc r13
   145                                  
   146                                  ; Start the loop to iterate through the decimal portion of the ASCII string for conversion FORWARDS
   147                                  convert_dec_portion:
   148                                  
   149                                  ; Convert the ASCII char by subtracting the ASCII code for '0' to the current character to yield the integer value
   150 0000009B 438A042C                mov al, byte[r12 + r13]
   151 0000009F 2C30                    sub al, '0'
   152                                  
   153                                  ; Convert the extracted integer value into a float, divide it by the place value (xmm13), then add it to our sum (xmm12)
   154 000000A1 F24C0F2AF0              cvtsi2sd xmm14, rax
   155 000000A6 F2450F5EF5              divsd xmm14, xmm13
   156 000000AB F2450F58F4              addsd xmm14, xmm12
   157                                  
   158                                  ; Increment the index of the decimal place (r13) by 1 and the place value (xmm13) by 10
   159 000000B0 49FFC5                  inc r13
   160 000000B3 F2450F59EB              mulsd xmm13, xmm11
   161                                  
   162                                  ; Check if we have reached a null terminator character by checking if the current character = 0. If so, continue to finalize the float. Otherwise, reset the loop
   163 000000B8 43803C2C00              cmp byte[r12 + r13], 0
   164 000000BD 74DC                    je convert_dec_portion
   165                                  
   166                                  ; From here, finalize the float. Start by adding the integer (r14) and decimal (xmm14) portions together.
   167 000000BF F24D0F2AD6              cvtsi2sd xmm10, r14
   168 000000C4 F2450F58F2              addsd xmm14, xmm10
   169                                  
   170                                  ; Check if the negative flag (r10) was turned on. If so, continue. Otherwise, jump to return.
   171 000000C9 4983FA01                cmp r10, 1
   172 000000CD 740E                    je return
   173                                  
   174                                  ; Convert the float into a negative by flipping on its first bit using a mask
   175 000000CF F20F100C25-             movsd xmm1, [negative_mask]
   175 000000D4 [00000000]         
   176 000000D8 66440F57F1              xorpd xmm14, xmm1
   177                                  
   178                                  ; End of convert_dec_portion to convert the decimal portion of the ASCII string and finalize conversion into a float
   179                                  
   180                                  ; Jump here to return to the caller
   181                                  return:
   182                                  
   183                                  ; Prepare to send back the generated float by pushing it to the stack
   184 000000DD 6A00                    push qword 0
   185 000000DF F2440F113424            movsd [rsp], xmm14
   186                                  
   187                                  ; Call the macro to restore the non-GPRs/SSEs from backup_storage_area
   188                                  restore_non_gprs backup_storage_area
   109 000000E5 B807000000          <1>  mov rax, 7
   110 000000EA BA00000000          <1>  mov rdx, 0
   111 000000EF 0FAE2C25[00000000]  <1>  xrstor [%1]
   189                                  
   190                                  ; Send back the generated float
   191 000000F7 F20F100424              movsd xmm0, [rsp]
   192 000000FC 58                      pop rax
   193                                  
   194                                  ; Call the macro to restore the GPRs
   195                                  restore_gprs
    83 000000FD 9D                  <1>  popf
    84 000000FE 415F                <1>  pop r15
    85 00000100 415E                <1>  pop r14
    86 00000102 415D                <1>  pop r13
    87 00000104 415C                <1>  pop r12
    88 00000106 415B                <1>  pop r11
    89 00000108 415A                <1>  pop r10
    90 0000010A 4159                <1>  pop r9
    91 0000010C 4158                <1>  pop r8
    92 0000010E 5E                  <1>  pop rsi
    93 0000010F 5F                  <1>  pop rdi
    94 00000110 5A                  <1>  pop rdx
    95 00000111 59                  <1>  pop rcx
    96 00000112 5B                  <1>  pop rbx
    97 00000113 5D                  <1>  pop rbp
   196                                  
   197 00000114 C3                      ret

     1                                  ;****************************************************************************************************************************
     2                                  ; Program name: "Electricity".  The intent of this program is to compute missing electrical information from            *
     3                                  ; user-inputted information. The educational purpose is to provide me with experience in pure assembly programming.          *                                                         *
     4                                  ; Copyright (C) 2025  Solivan Hiep                                                                                           *
     5                                  ; This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License  *
     6                                  ; version 3 as published by the Free Software Foundation.                                                                    *
     7                                  ; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied         *
     8                                  ; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     *
     9                                  ; A copy of the GNU General Public License v3 is available here:  <https://www.gnu.org/licenses/>.                           *
    10                                  ;****************************************************************************************************************************
    11                                  
    12                                  
    13                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
    14                                  
    15                                  ;Author information
    16                                  ;  Author name: Solivan Hiep
    17                                  ;  Author email: hiepsolivan@csu.fullerton.edu
    18                                  ;  CWID: 8848458756
    19                                  ;  Class: CPSC 240-03 - Class Nbr 13604
    20                                  ;
    21                                  ;Program information
    22                                  ;  Program name: Electricity
    23                                  ;  Programming languages: Ten modules in X86, one in bash
    24                                  ;  Date program began: 2025-Apr-04
    25                                  ;  Date of last update: 2025-Apr-12
    26                                  ;  Files in the program: faraday.asm, edison.asm, input_array.asm, atof.asm, isfloat.asm tesla.asm, ftoa.asm, syscall_fgets.asm, syscall_strlen.asm acdc.inc, r.sh
    27                                  ;
    28                                  ;Purpose
    29                                  ;  The intent of this program is to compute missing electrical information from
    30                                  ;  user-inputted information. The educational purpose is to provide me with experience in pure assembly programming.
    31                                  ;
    32                                  ;This file
    33                                  ;  File name: input_array.asm
    34                                  ;  Language: X86-64
    35                                  ;  Development Platform: Windows 11 Enterprise Ver. 24H2. Intel(R) Core(TM) i3-8145U CPU @ 2.10GHz 2.30 GHz Processor. Running on Ubuntu 22.04.5 LTS.
    36                                  ;  Max page width: 189 columns
    37                                  ;  Assemble: nasm -f elf64 -l input_array.lis -o input_array.o input_array.asm
    38                                  ;  Assemble (debug in GDB): nasm -f elf64 -gdwarf -l input_array.lis -o input_array.o input_array.asm
    39                                  ;  Page width: 198 columns
    40                                  ;  Optimal print specification: Landscape, 7 points, monospace, 8Â½x11 paper
    41                                  ;  Prototype of this function: void input_array(double array[], long capacity)
    42                                  ;
    43                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
    44                                  ;
    45                                  ;===== Begin code area ====================================================================================================================================================
    46                                  
    47                                  ; Declarations
    48                                  %include "acdc.inc"
    49                              <1> ;=====Declarations =======================================================================
    50                              <1> ;These declarations are global to all the macros in this include file "acdc.inc".
    51                              <1> SYS_READ equ 0
    52                              <1> SYS_WRITE equ 1
    53                              <1> STDIN equ 0
    54                              <1> STDOUT equ 1
    55                              <1> 
    56                              <1> LF equ 10
    57                              <1> NULL equ 0
    58                              <1> 
    59 00000000 0A0A0A0A0A0A0A0A    <1> newline db 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa
    60                              <1> 
    61                              <1> ; Macro that backs up the GPRs
    62                              <1> %macro backup_gprs 0
    63                              <1>   push rbp
    64                              <1>   mov rbp, rsp
    65                              <1>   push rbx
    66                              <1>   push rcx
    67                              <1>   push rdx
    68                              <1>   push rdi
    69                              <1>   push rsi
    70                              <1>   push r8
    71                              <1>   push r9
    72                              <1>   push r10
    73                              <1>   push r11
    74                              <1>   push r12
    75                              <1>   push r13
    76                              <1>   push r14
    77                              <1>   push r15
    78                              <1>   pushf
    79                              <1> %endmacro
    80                              <1> 
    81                              <1> ; Macro that restores the GPRs
    82                              <1> %macro restore_gprs 0
    83                              <1>   popf
    84                              <1>   pop r15
    85                              <1>   pop r14
    86                              <1>   pop r13
    87                              <1>   pop r12
    88                              <1>   pop r11
    89                              <1>   pop r10
    90                              <1>   pop r9
    91                              <1>   pop r8
    92                              <1>   pop rsi
    93                              <1>   pop rdi
    94                              <1>   pop rdx
    95                              <1>   pop rcx
    96                              <1>   pop rbx
    97                              <1>   pop rbp
    98                              <1> %endmacro
    99                              <1> 
   100                              <1> ; Macro that back ups non-GPRs/SSEs to an array stored in parameter %1
   101                              <1> %macro backup_non_gprs 1
   102                              <1>   mov rax, 7
   103                              <1>   mov rdx, 0
   104                              <1>   xsave [%1]
   105                              <1> %endmacro
   106                              <1> 
   107                              <1> ; Macro that restores the non-GPRs/SSEs in storage array of parameter %1
   108                              <1> %macro restore_non_gprs 1
   109                              <1>   mov rax, 7
   110                              <1>   mov rdx, 0
   111                              <1>   xrstor [%1]
   112                              <1> %endmacro
   113                              <1> 
   114                              <1> ; Macro to print a newline
   115                              <1> %macro new_line 0
   116                              <1>   mov rax, SYS_WRITE
   117                              <1>   mov rdi, STDOUT
   118                              <1>   mov rsi, newline
   119                              <1>   mov rdx, 1
   120                              <1>   syscall
   121                              <1> %endmacro
   122                              <1> 
   123                              <1> ; Macro that reads each individual character from user input to store in parameter %1 [Limit: 50 chars (same as size of parameter %1)]
   124                              <1> %macro syscall_user_input_macro 1
   125                              <1>   ; %1 = Where to store the string
   126                              <1>   mov rbx, %1
   127                              <1> 
   128                              <1>   ; Maintain a counter to avoid over-indexing
   129                              <1>   xor r8, r8
   130                              <1> 
   131                              <1>   ; Set off the loop to read each character
   132                              <1>   %%read_chars:
   133                              <1>   ; Obtain one character from the user
   134                              <1>   mov rax, SYS_READ
   135                              <1>   mov rdi, STDIN
   136                              <1>   lea rsi, byte[chr] ; Use lea (Load Effective Address) to get the address of the character to be read
   137                              <1>   mov rdx, 1 ; Read one character
   138                              <1>   syscall
   139                              <1> 
   140                              <1>   ; Obtain the character from syscall stored in al [the low of rax's low's low] and check if its '\n' [Line feed]. If so, jump out; otherwise, continue
   141                              <1>   mov al, byte[chr]
   142                              <1>   cmp al, LF
   143                              <1>   je %%read_done
   144                              <1> 
   145                              <1>   ; Increment the counter and compare it to the max string size. If the counter is greater or equal, reset the loop to stop placing chars in the buffer. Otherwise, continue
   146                              <1>   inc r8
   147                              <1>   cmp r8, 50
   148                              <1>   jge %%read_chars ; Doing this will force the above read_done jump as the buffer is now cleared
   149                              <1> 
   150                              <1>   ; Update the string at the index r8 and the address of the string
   151                              <1>   mov byte[rbx], al
   152                              <1>   inc rbx
   153                              <1> 
   154                              <1>   ; Reset the loop
   155                              <1>   jmp %%read_chars
   156                              <1>   ; End of read_chars to read each character from user input
   157                              <1> 
   158                              <1>   ; Jump here once you are finished reading
   159                              <1>   %%read_done:
   160                              <1> 
   161                              <1>   ; Add a null terminator character to the end of the string
   162                              <1>   mov byte[rbx], NULL
   163                              <1> %endmacro
   164                              <1> 
   165                              <1> ; Macro that obtains the string length of the string stored in parameter %1 to output into parameter %2
   166                              <1> %macro syscall_strlen_macro 2
   167                              <1>   ; %1 - The string to find the length of
   168                              <1>   ; %2 - The length of the string
   169                              <1>   mov r12, %1
   170                              <1> 
   171                              <1>   ; Maintain a counter for each character
   172                              <1>   xor r8, r8
   173                              <1> 
   174                              <1>   ; Load the effective address of the string to use as an index
   175                              <1>   lea r9, [r12]
   176                              <1> 
   177                              <1>   ; Kick of the loop to get the string length
   178                              <1>   %%count_chars:
   179                              <1>   ; Check for the null character. If at null char, jump. Otherwise, continue
   180                              <1>   cmp byte [r9], 0
   181                              <1>   je %%count_done
   182                              <1> 
   183                              <1>   ; Increment both the character count and index then reset the loop
   184                              <1>   inc r8
   185                              <1>   inc r9
   186                              <1>   jmp %%count_chars
   187                              <1>   ; End of count_chars to obtain the string length
   188                              <1> 
   189                              <1>   ; Jump here to exit the macro
   190                              <1>   %%count_done:
   191                              <1>   mov %2, r8
   192                              <1> 
   193                              <1> %endmacro
    49                                  global input_array
    50                                  extern atof
    51                                  extern isfloat
    52                                  extern syscall_fgets
    53                                  
    54                                  SYS_WRITE equ 1
    55                                  STDOUT equ 1
    56                                  
    57                                  ; Declare initialized arrays
    58                                  segment .data
    59 00000000 4465627567              debug db "Debug"
    60 00000005 546865206C61737420-     fail_msg db "The last input was invalid and not entered into the array.  Try again."
    60 0000000E 696E70757420776173-
    60 00000017 20696E76616C696420-
    60 00000020 616E64206E6F742065-
    60 00000029 6E746572656420696E-
    60 00000032 746F20746865206172-
    60 0000003B 7261792E2020547279-
    60 00000044 20616761696E2E     
    61                                  
    62                                  ; Declare uninitialized arrats
    63                                  segment .bss
    64                                  align 64
    65 00000000 <res 340h>              backup_storage_area resb 832
    66                                  
    67                                  segment .text
    68                                  input_array:
    69                                  ; Call the macro to back up the GPRs
    70                                  backup_gprs
    63 00000008 55                  <1>  push rbp
    64 00000009 4889E5              <1>  mov rbp, rsp
    65 0000000C 53                  <1>  push rbx
    66 0000000D 51                  <1>  push rcx
    67 0000000E 52                  <1>  push rdx
    68 0000000F 57                  <1>  push rdi
    69 00000010 56                  <1>  push rsi
    70 00000011 4150                <1>  push r8
    71 00000013 4151                <1>  push r9
    72 00000015 4152                <1>  push r10
    73 00000017 4153                <1>  push r11
    74 00000019 4154                <1>  push r12
    75 0000001B 4155                <1>  push r13
    76 0000001D 4156                <1>  push r14
    77 0000001F 4157                <1>  push r15
    78 00000021 9C                  <1>  pushf
    71                                  
    72                                  ; Call the macro to back up the non-GPRs/SSEs into backup_storage_area
    73                                  backup_non_gprs backup_storage_area
   102 00000022 B807000000          <1>  mov rax, 7
   103 00000027 BA00000000          <1>  mov rdx, 0
   104 0000002C 0FAE2425[00000000]  <1>  xsave [%1]
    74                                  
    75                                  ; Move the arguments received (the address to the array + array capacity) into non-volatile registers r12 and r13 to affect the actual array + future use in logic
    76 00000034 4989FC                  mov r12, rdi ; The array
    77 00000037 4989F5                  mov r13, rsi ; The array's capacity
    78                                  
    79                                  ; Maintain a counter to prevent over-indexing
    80 0000003A 4D31F6                  xor r14, r14
    81                                  
    82                                  ; Kick of the main loop to ask for user input to insert into an array
    83                                  top_of_loop:
    84                                  
    85                                  ; Check for over-indexing by determining if r14 >= r13. If so, exit. Otherwise, continue
    86 0000003D 4D39EE                  cmp r14, r13
    87 00000040 7D5D                    jge out_of_loop
    88                                  
    89                                  ; Prompt for user input of the array through syscall_fgets [void syscall_fgets(char string[])] to place input on the stack
    90 00000042 6A00                    push qword 0
    91 00000044 6A00                    push qword 0
    92 00000046 B800000000              mov rax, 0
    93 0000004B 4889E7                  mov rdi, rsp
    94 0000004E E8(00000000)            call syscall_fgets
    95                                  
    96                                  ; Validate the most recent input by calling isfloat [bool isfloat(char input[])]
    97 00000053 B800000000              mov rax, 0
    98 00000058 4889E7                  mov rdi, rsp
    99 0000005B E8(00000000)            call isfloat
   100 00000060 4883F800                cmp rax, 0 ; If isfloat returned a 0, then we did not get a float
   101 00000064 741A                    je try_again
   102                                  
   103                                  ; Now that we have a valid float, call atof (double atof(char string[])) to convert the ASCII string into a flaot
   104 00000066 B800000000              mov rax, 0
   105 0000006B 4889E7                  mov rdi, rsp
   106 0000006E E8(00000000)            call atof ; Stores float in xmm0
   107                                  
   108                                  ; Now that we are done with the stack, pop it.
   109 00000073 58                      pop rax
   110 00000074 58                      pop rax
   111                                  
   112                                  ; Insert the user-inputted float into the array [r12] at the counter [r14]
   113 00000075 F2430F1104F4            movsd [r12 + r14 * 8], xmm0
   114                                  
   115                                  ; Increment the counter and reset the loop if all goes well.
   116 0000007B 49FFC6                  inc r14
   117 0000007E EBBD                    jmp top_of_loop
   118                                  
   119                                  ; Jump here if you did not receive a float
   120                                  try_again:
   121                                  
   122                                  ; Print out the message explaining that the user did not input a float and should try again
   123 00000080 B801000000              mov rax, SYS_WRITE
   124 00000085 BF01000000              mov rdi, STDOUT
   125 0000008A 48BE-                   mov rsi, fail_msg
   125 0000008C [0500000000000000] 
   126 00000094 BA4A000000              mov rdx, 74
   127 00000099 0F05                    syscall
   128                                  
   129                                  ; Pop the failed input to avoid segmentation faults then jump back to the main loop
   130 0000009B 58                      pop rax
   131 0000009C 58                      pop rax
   132 0000009D EB9E                    jmp top_of_loop
   133                                  ; End of try_again to pop failed input and reset the main loop
   134                                  
   135                                  ; Exit the main loop and complete the program
   136                                  out_of_loop:
   137                                  
   138                                  ; Call the macro to restore the non-GPRs/SSEs from backup_storage_area
   139                                  restore_non_gprs backup_storage_area
   109 0000009F B807000000          <1>  mov rax, 7
   110 000000A4 BA00000000          <1>  mov rdx, 0
   111 000000A9 0FAE2C25[00000000]  <1>  xrstor [%1]
   140                                  
   141                                  ; Call the macro to restore the GPRs
   142                                  restore_gprs
    83 000000B1 9D                  <1>  popf
    84 000000B2 415F                <1>  pop r15
    85 000000B4 415E                <1>  pop r14
    86 000000B6 415D                <1>  pop r13
    87 000000B8 415C                <1>  pop r12
    88 000000BA 415B                <1>  pop r11
    89 000000BC 415A                <1>  pop r10
    90 000000BE 4159                <1>  pop r9
    91 000000C0 4158                <1>  pop r8
    92 000000C2 5E                  <1>  pop rsi
    93 000000C3 5F                  <1>  pop rdi
    94 000000C4 5A                  <1>  pop rdx
    95 000000C5 59                  <1>  pop rcx
    96 000000C6 5B                  <1>  pop rbx
    97 000000C7 5D                  <1>  pop rbp
   143                                  
   144 000000C8 C3                      ret
